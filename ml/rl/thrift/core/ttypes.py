#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys

from thrift.transport import TTransport


class RLParameters(object):
    """
    Attributes:
     - gamma
     - epsilon
     - target_update_rate
     - reward_burnin
     - maxq_learning
    """

    thrift_spec = (
        None,  # 0
        (1, TType.DOUBLE, 'gamma', None, 0.9, ),  # 1
        (2, TType.DOUBLE, 'epsilon', None, 0.1, ),  # 2
        (3, TType.DOUBLE, 'target_update_rate', None, 0.01, ),  # 3
        (4, TType.I32, 'reward_burnin', None, 1, ),  # 4
        (5, TType.BOOL, 'maxq_learning', None, True, ),  # 5
    )

    def __init__(self, gamma=thrift_spec[1][4], epsilon=thrift_spec[2][4], target_update_rate=thrift_spec[3][4], reward_burnin=thrift_spec[4][4], maxq_learning=thrift_spec[5][4],):
        self.gamma = gamma
        self.epsilon = epsilon
        self.target_update_rate = target_update_rate
        self.reward_burnin = reward_burnin
        self.maxq_learning = maxq_learning

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.gamma = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.epsilon = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.target_update_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.reward_burnin = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.maxq_learning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('RLParameters')
        if self.gamma is not None:
            oprot.writeFieldBegin('gamma', TType.DOUBLE, 1)
            oprot.writeDouble(self.gamma)
            oprot.writeFieldEnd()
        if self.epsilon is not None:
            oprot.writeFieldBegin('epsilon', TType.DOUBLE, 2)
            oprot.writeDouble(self.epsilon)
            oprot.writeFieldEnd()
        if self.target_update_rate is not None:
            oprot.writeFieldBegin('target_update_rate', TType.DOUBLE, 3)
            oprot.writeDouble(self.target_update_rate)
            oprot.writeFieldEnd()
        if self.reward_burnin is not None:
            oprot.writeFieldBegin('reward_burnin', TType.I32, 4)
            oprot.writeI32(self.reward_burnin)
            oprot.writeFieldEnd()
        if self.maxq_learning is not None:
            oprot.writeFieldBegin('maxq_learning', TType.BOOL, 5)
            oprot.writeBool(self.maxq_learning)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TrainingParameters(object):
    """
    Attributes:
     - minibatch_size
     - learning_rate
     - optimizer
     - layers
     - activations
     - lr_policy
     - gamma
     - dropout_ratio
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'minibatch_size', None, 16384, ),  # 1
        (2, TType.DOUBLE, 'learning_rate', None, 0.01, ),  # 2
        (3, TType.STRING, 'optimizer', 'UTF8', "ADAM", ),  # 3
        (4, TType.LIST, 'layers', (TType.I32, None, False), [
            -1,
            512,
            256,
            128,
            1,
        ], ),  # 4
        (5, TType.LIST, 'activations', (TType.STRING, 'UTF8', False), [
            "relu",
            "relu",
            "relu",
            "linear",
        ], ),  # 5
        (6, TType.STRING, 'lr_policy', 'UTF8', "fixed", ),  # 6
        (7, TType.DOUBLE, 'gamma', None, 0.999, ),  # 7
        (8, TType.DOUBLE, 'dropout_ratio', None, 0, ),  # 8
    )

    def __init__(self, minibatch_size=thrift_spec[1][4], learning_rate=thrift_spec[2][4], optimizer=thrift_spec[3][4], layers=thrift_spec[4][4], activations=thrift_spec[5][4], lr_policy=thrift_spec[6][4], gamma=thrift_spec[7][4], dropout_ratio=thrift_spec[8][4],):
        self.minibatch_size = minibatch_size
        self.learning_rate = learning_rate
        self.optimizer = optimizer
        if layers is self.thrift_spec[4][4]:
            layers = [
                -1,
                512,
                256,
                128,
                1,
            ]
        self.layers = layers
        if activations is self.thrift_spec[5][4]:
            activations = [
                "relu",
                "relu",
                "relu",
                "linear",
            ]
        self.activations = activations
        self.lr_policy = lr_policy
        self.gamma = gamma
        self.dropout_ratio = dropout_ratio

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minibatch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.optimizer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.layers = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.layers.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.activations = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.activations.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.lr_policy = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.gamma = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.dropout_ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TrainingParameters')
        if self.minibatch_size is not None:
            oprot.writeFieldBegin('minibatch_size', TType.I32, 1)
            oprot.writeI32(self.minibatch_size)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 2)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        if self.optimizer is not None:
            oprot.writeFieldBegin('optimizer', TType.STRING, 3)
            oprot.writeString(self.optimizer.encode('utf-8') if sys.version_info[0] == 2 else self.optimizer)
            oprot.writeFieldEnd()
        if self.layers is not None:
            oprot.writeFieldBegin('layers', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.layers))
            for iter12 in self.layers:
                oprot.writeI32(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activations is not None:
            oprot.writeFieldBegin('activations', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.activations))
            for iter13 in self.activations:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lr_policy is not None:
            oprot.writeFieldBegin('lr_policy', TType.STRING, 6)
            oprot.writeString(self.lr_policy.encode('utf-8') if sys.version_info[0] == 2 else self.lr_policy)
            oprot.writeFieldEnd()
        if self.gamma is not None:
            oprot.writeFieldBegin('gamma', TType.DOUBLE, 7)
            oprot.writeDouble(self.gamma)
            oprot.writeFieldEnd()
        if self.dropout_ratio is not None:
            oprot.writeFieldBegin('dropout_ratio', TType.DOUBLE, 8)
            oprot.writeDouble(self.dropout_ratio)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ActionBudget(object):
    """
    Attributes:
     - limited_action
     - action_limit
     - quantile_update_rate
     - quantile_update_frequency
     - window_size
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'limited_action', 'UTF8', None, ),  # 1
        (2, TType.DOUBLE, 'action_limit', None, None, ),  # 2
        (3, TType.DOUBLE, 'quantile_update_rate', None, 0.01, ),  # 3
        (4, TType.I32, 'quantile_update_frequency', None, 10, ),  # 4
        (5, TType.I32, 'window_size', None, 16384, ),  # 5
    )

    def __init__(self, limited_action=None, action_limit=None, quantile_update_rate=thrift_spec[3][4], quantile_update_frequency=thrift_spec[4][4], window_size=thrift_spec[5][4],):
        self.limited_action = limited_action
        self.action_limit = action_limit
        self.quantile_update_rate = quantile_update_rate
        self.quantile_update_frequency = quantile_update_frequency
        self.window_size = window_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.limited_action = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.action_limit = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.quantile_update_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.quantile_update_frequency = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.window_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ActionBudget')
        if self.limited_action is not None:
            oprot.writeFieldBegin('limited_action', TType.STRING, 1)
            oprot.writeString(self.limited_action.encode('utf-8') if sys.version_info[0] == 2 else self.limited_action)
            oprot.writeFieldEnd()
        if self.action_limit is not None:
            oprot.writeFieldBegin('action_limit', TType.DOUBLE, 2)
            oprot.writeDouble(self.action_limit)
            oprot.writeFieldEnd()
        if self.quantile_update_rate is not None:
            oprot.writeFieldBegin('quantile_update_rate', TType.DOUBLE, 3)
            oprot.writeDouble(self.quantile_update_rate)
            oprot.writeFieldEnd()
        if self.quantile_update_frequency is not None:
            oprot.writeFieldBegin('quantile_update_frequency', TType.I32, 4)
            oprot.writeI32(self.quantile_update_frequency)
            oprot.writeFieldEnd()
        if self.window_size is not None:
            oprot.writeFieldBegin('window_size', TType.I32, 5)
            oprot.writeI32(self.window_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiscreteActionModelParameters(object):
    """
    Attributes:
     - actions
     - rl
     - training
     - action_budget
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'actions', (TType.STRING, 'UTF8', False), None, ),  # 1
        (2, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), RLParameters(**{
        }), ),  # 2
        (3, TType.STRUCT, 'training', (TrainingParameters, TrainingParameters.thrift_spec), TrainingParameters(**{
        }), ),  # 3
        (4, TType.STRUCT, 'action_budget', (ActionBudget, ActionBudget.thrift_spec), None, ),  # 4
    )

    def __init__(self, actions=None, rl=thrift_spec[2][4], training=thrift_spec[3][4], action_budget=None,):
        self.actions = actions
        if rl is self.thrift_spec[2][4]:
            rl = RLParameters(**{
            })
        self.rl = rl
        if training is self.thrift_spec[3][4]:
            training = TrainingParameters(**{
            })
        self.training = training
        self.action_budget = action_budget

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.actions = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.actions.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.training = TrainingParameters()
                    self.training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_budget = ActionBudget()
                    self.action_budget.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('DiscreteActionModelParameters')
        if self.actions is not None:
            oprot.writeFieldBegin('actions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.actions))
            for iter20 in self.actions:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 2)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.training is not None:
            oprot.writeFieldBegin('training', TType.STRUCT, 3)
            self.training.write(oprot)
            oprot.writeFieldEnd()
        if self.action_budget is not None:
            oprot.writeFieldBegin('action_budget', TType.STRUCT, 4)
            self.action_budget.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KnnParameters(object):
    """
    Attributes:
     - model_type
     - knn_frequency
     - knn_k
     - knn_dynreindex
     - knn_dynreindex_threshold
     - knn_dynreindex_rand_other
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'model_type', 'UTF8', None, ),  # 1
        (2, TType.I32, 'knn_frequency', None, None, ),  # 2
        (3, TType.I32, 'knn_k', None, None, ),  # 3
        (4, TType.BOOL, 'knn_dynreindex', None, None, ),  # 4
        (5, TType.DOUBLE, 'knn_dynreindex_threshold', None, None, ),  # 5
        (6, TType.I32, 'knn_dynreindex_rand_other', None, None, ),  # 6
    )

    def __init__(self, model_type=None, knn_frequency=None, knn_k=None, knn_dynreindex=None, knn_dynreindex_threshold=None, knn_dynreindex_rand_other=None,):
        self.model_type = model_type
        self.knn_frequency = knn_frequency
        self.knn_k = knn_k
        self.knn_dynreindex = knn_dynreindex
        self.knn_dynreindex_threshold = knn_dynreindex_threshold
        self.knn_dynreindex_rand_other = knn_dynreindex_rand_other

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.model_type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.knn_frequency = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.knn_k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.knn_dynreindex = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.knn_dynreindex_threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.knn_dynreindex_rand_other = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('KnnParameters')
        if self.model_type is not None:
            oprot.writeFieldBegin('model_type', TType.STRING, 1)
            oprot.writeString(self.model_type.encode('utf-8') if sys.version_info[0] == 2 else self.model_type)
            oprot.writeFieldEnd()
        if self.knn_frequency is not None:
            oprot.writeFieldBegin('knn_frequency', TType.I32, 2)
            oprot.writeI32(self.knn_frequency)
            oprot.writeFieldEnd()
        if self.knn_k is not None:
            oprot.writeFieldBegin('knn_k', TType.I32, 3)
            oprot.writeI32(self.knn_k)
            oprot.writeFieldEnd()
        if self.knn_dynreindex is not None:
            oprot.writeFieldBegin('knn_dynreindex', TType.BOOL, 4)
            oprot.writeBool(self.knn_dynreindex)
            oprot.writeFieldEnd()
        if self.knn_dynreindex_threshold is not None:
            oprot.writeFieldBegin('knn_dynreindex_threshold', TType.DOUBLE, 5)
            oprot.writeDouble(self.knn_dynreindex_threshold)
            oprot.writeFieldEnd()
        if self.knn_dynreindex_rand_other is not None:
            oprot.writeFieldBegin('knn_dynreindex_rand_other', TType.I32, 6)
            oprot.writeI32(self.knn_dynreindex_rand_other)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ContinuousActionModelParameters(object):
    """
    Attributes:
     - rl
     - training
     - knn
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), RLParameters(**{
        }), ),  # 1
        (2, TType.STRUCT, 'training', (TrainingParameters, TrainingParameters.thrift_spec), TrainingParameters(**{
        }), ),  # 2
        (3, TType.STRUCT, 'knn', (KnnParameters, KnnParameters.thrift_spec), None, ),  # 3
    )

    def __init__(self, rl=thrift_spec[1][4], training=thrift_spec[2][4], knn=None,):
        if rl is self.thrift_spec[1][4]:
            rl = RLParameters(**{
            })
        self.rl = rl
        if training is self.thrift_spec[2][4]:
            training = TrainingParameters(**{
            })
        self.training = training
        self.knn = knn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.training = TrainingParameters()
                    self.training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.knn = KnnParameters()
                    self.knn.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ContinuousActionModelParameters')
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 1)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.training is not None:
            oprot.writeFieldBegin('training', TType.STRUCT, 2)
            self.training.write(oprot)
            oprot.writeFieldEnd()
        if self.knn is not None:
            oprot.writeFieldBegin('knn', TType.STRUCT, 3)
            self.knn.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>reagent.replay_memory package &mdash; ReAgent 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="reagent.training package" href="reagent.training.html" />
    <link rel="prev" title="reagent.preprocessing package" href="reagent.preprocessing.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ReAgent
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rasp_tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../distributed.html">Distributed Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../continuous_integration.html">Continuous Integration</a></li>
</ul>
<p class="caption"><span class="caption-text">Package Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ml.rl.evaluation.html">Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.prediction.html">Prediction</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.readers.html">Readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.simulators.html">Simulators</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.training.html">Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.rl.workflow.html">Workflow</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">All Modules</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="reagent.html">reagent package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="reagent.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="reagent.evaluation.html">reagent.evaluation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.gym.html">reagent.gym package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.models.html">reagent.models package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.ope.html">reagent.ope package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.optimizer.html">reagent.optimizer package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.prediction.html">reagent.prediction package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.preprocessing.html">reagent.preprocessing package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">reagent.replay_memory package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.training.html">reagent.training package</a></li>
<li class="toctree-l4"><a class="reference internal" href="reagent.workflow.html">reagent.workflow package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.base_dataclass">reagent.base_dataclass module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.debug_on_error">reagent.debug_on_error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.json_serialize">reagent.json_serialize module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#reagent-parameters-module">reagent.parameters module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.parameters_seq2slate">reagent.parameters_seq2slate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.tensorboardX">reagent.tensorboardX module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.torch_utils">reagent.torch_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent.types">reagent.types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="reagent.html#module-reagent">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Others</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/facebookresearch/ReAgent">Github</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ReAgent</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">reagent</a> &raquo;</li>
        
          <li><a href="reagent.html">reagent package</a> &raquo;</li>
        
      <li>reagent.replay_memory package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/reagent.replay_memory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reagent-replay-memory-package">
<h1>reagent.replay_memory package<a class="headerlink" href="#reagent-replay-memory-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-reagent.replay_memory.circular_replay_buffer">
<span id="reagent-replay-memory-circular-replay-buffer-module"></span><h2>reagent.replay_memory.circular_replay_buffer module<a class="headerlink" href="#module-reagent.replay_memory.circular_replay_buffer" title="Permalink to this headline">¶</a></h2>
<p>The standard DQN replay memory.
This implementation is an out-of-graph replay memory + in-graph wrapper. It
supports vanilla n-step updates of the form typically found in the literature,
i.e. where rewards are accumulated for n steps and the intermediate trajectory
is not exposed to the agent. This does not allow, for example, performing
off-policy corrections.</p>
<dl class="class">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer">
<em class="property">class </em><code class="sig-prename descclassname">reagent.replay_memory.circular_replay_buffer.</code><code class="sig-name descname">ReplayBuffer</code><span class="sig-paren">(</span><em class="sig-param">observation_shape: Tuple[int, ...], stack_size: int, replay_capacity: int, batch_size: int, return_everything_as_stack: bool = False, return_as_timeline_format: bool = False, update_horizon: int = 1, gamma: float = 0.99, max_sample_attempts: int = 1000, extra_storage_types: Optional[List[reagent.replay_memory.circular_replay_buffer.shape_type]] = None, observation_dtype=numpy.uint8, action_shape: Tuple[int, ...] = (), action_dtype=numpy.int32, reward_shape: Tuple[int, ...] = (), reward_dtype=numpy.float32</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple Replay Buffer.
Stores transitions, state, action, reward, next_state, terminal (and any
extra contents specified) in a circular buffer and provides a uniform
transition sampling function.
When the states consist of stacks of observations storing the states is
inefficient. This class writes observations and constructs the stacked states
at sample time.
.. attribute:: add_count</p>
<blockquote>
<div><p>int, counter of how many transitions have been added (including
the blank ones at the beginning of an episode).</p>
</div></blockquote>
<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">observation</em>, <em class="sig-param">action</em>, <em class="sig-param">reward</em>, <em class="sig-param">terminal</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a transition to the replay memory.
This function checks the types and handles the padding at the beginning of
an episode. Then it calls the _add function.
Since the next_observation in the transition will be the observation added
next there is no need to pass it.
If the replay memory is at capacity the oldest transition will be discarded.
:param observation: np.array with shape observation_shape.
:param action: int, the action in the transition.
:param reward: float, the reward received in the transition.
:param terminal: np.dtype, acts as a boolean indicating whether the transition</p>
<blockquote>
<div><p>was terminal (1) or not (0).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*args</strong> – extra contents with shapes and dtypes according to
extra_storage_types.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.create_from_env">
<em class="property">classmethod </em><code class="sig-name descname">create_from_env</code><span class="sig-paren">(</span><em class="sig-param">env: gym.core.Env</em>, <em class="sig-param">*</em>, <em class="sig-param">replay_memory_size: int</em>, <em class="sig-param">batch_size: int</em>, <em class="sig-param">stack_size: int = 1</em>, <em class="sig-param">store_log_prob: bool = True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.create_from_env" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.cursor">
<code class="sig-name descname">cursor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Index to the location where the next transition will be written.</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_add_args_signature">
<code class="sig-name descname">get_add_args_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[reagent.replay_memory.circular_replay_buffer.shape_type]<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_add_args_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>The signature of the add function.
Note - Derived classes may return a different signature.
:returns:</p>
<blockquote>
<div><dl class="simple">
<dt>list of ReplayElements defining the type of the argument signature needed</dt><dd><p>by the add function.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_storage_signature">
<code class="sig-name descname">get_storage_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[reagent.replay_memory.circular_replay_buffer.shape_type]<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_storage_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a default list of elements to be stored in this replay memory.
Note - Derived classes may return a different signature.
:returns: list of ReplayElements defining the type of the contents stored.</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_transition_elements">
<code class="sig-name descname">get_transition_elements</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.get_transition_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ‘type signature’ for sample_transition_batch.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A namedtuple describing the method’s return type signature.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>signature</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_empty">
<code class="sig-name descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Replay Buffer empty?</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_full">
<code class="sig-name descname">is_full</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Replay Buffer full?</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_valid_transition">
<code class="sig-name descname">is_valid_transition</code><span class="sig-paren">(</span><em class="sig-param">index</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.is_valid_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">checkpoint_dir</em>, <em class="sig-param">suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores the object from bundle_dictionary and numpy checkpoints.
:param checkpoint_dir: str, the directory where to read the numpy checkpointed</p>
<blockquote>
<div><p>files from.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>suffix</strong> – str, the suffix to use in numpy checkpoint files.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotFoundError</strong> – If not all expected files are found in directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_all_valid_transitions">
<code class="sig-name descname">sample_all_valid_transitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_all_valid_transitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_index_batch">
<code class="sig-name descname">sample_index_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size: int</em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_index_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of valid indices sampled uniformly.
:param batch_size: int, number of indices returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1D tensor of ints, a batch of valid indices sampled uniformly.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If there are no valid indices to sample.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_transition_batch">
<code class="sig-name descname">sample_transition_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.sample_transition_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of transitions (including any extra contents).
If get_transition_elements has been overridden and defines elements not
stored in self._store, an empty array will be returned and it will be
left to the child class to fill it. For example, for the child class
PrioritizedReplayBuffer, the contents of the
sampling_probabilities are stored separately in a sum tree.
When the transition is terminal next_state_batch has undefined contents.
NOTE: This transition contains the indices of the sampled elements. These
are only valid during the call to sample_transition_batch, i.e. they may
be used by subclasses of this replay buffer but may point to different data
as soon as sampling is done.
NOTE: Tensors are reshaped. I.e., state is 2-D unless stack_size &gt; 1.
Scalar values are returned as (batch_size, 1) instead of (batch_size,).
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>indices</strong> – None or Tensor, the indices of every transition in the
batch. If None, sample the indices uniformly.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>tuple of Tensors with the shape and type as in</dt><dd><p>get_transition_elements().</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>transition_batch</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an element to be sampled is missing from the replay buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">checkpoint_dir</em>, <em class="sig-param">iteration_number</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the ReplayBuffer attributes into a file.
This method will save all the replay buffer’s state in a single file.
:param checkpoint_dir: str, the directory where numpy checkpoint files should be</p>
<blockquote>
<div><p>saved.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iteration_number</strong> – int, iteration_number to use as a suffix in naming
numpy checkpoint files.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.set_index_valid_status">
<code class="sig-name descname">set_index_valid_status</code><span class="sig-paren">(</span><em class="sig-param">idx: int</em>, <em class="sig-param">is_valid: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.set_index_valid_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayBuffer.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="reagent.replay_memory.circular_replay_buffer.ReplayElement">
<code class="sig-prename descclassname">reagent.replay_memory.circular_replay_buffer.</code><code class="sig-name descname">ReplayElement</code><a class="headerlink" href="#reagent.replay_memory.circular_replay_buffer.ReplayElement" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">reagent.replay_memory.circular_replay_buffer.shape_type</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-reagent.replay_memory.prioritized_replay_buffer">
<span id="reagent-replay-memory-prioritized-replay-buffer-module"></span><h2>reagent.replay_memory.prioritized_replay_buffer module<a class="headerlink" href="#module-reagent.replay_memory.prioritized_replay_buffer" title="Permalink to this headline">¶</a></h2>
<p>An implementation of Prioritized Experience Replay (PER).
This implementation is based on the paper “Prioritized Experience Replay”
by Tom Schaul et al. (2015). Many thanks to Tom Schaul, John Quan, and Matteo
Hessel for providing useful pointers on the algorithm and its implementation.</p>
<dl class="class">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer">
<em class="property">class </em><code class="sig-prename descclassname">reagent.replay_memory.prioritized_replay_buffer.</code><code class="sig-name descname">PrioritizedReplayBuffer</code><span class="sig-paren">(</span><em class="sig-param">observation_shape</em>, <em class="sig-param">stack_size</em>, <em class="sig-param">replay_capacity</em>, <em class="sig-param">batch_size</em>, <em class="sig-param">update_horizon=1</em>, <em class="sig-param">gamma=0.99</em>, <em class="sig-param">max_sample_attempts=1000</em>, <em class="sig-param">extra_storage_types=None</em>, <em class="sig-param">observation_dtype=numpy.uint8</em>, <em class="sig-param">action_shape=()</em>, <em class="sig-param">action_dtype=numpy.int32</em>, <em class="sig-param">reward_shape=()</em>, <em class="sig-param">reward_dtype=numpy.float32</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer" title="reagent.replay_memory.circular_replay_buffer.ReplayBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">reagent.replay_memory.circular_replay_buffer.ReplayBuffer</span></code></a></p>
<p>An out-of-graph Replay Buffer for Prioritized Experience Replay.
See circular_replay_buffer.py for details.</p>
<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_add_args_signature">
<code class="sig-name descname">get_add_args_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_add_args_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>The signature of the add function.
The signature is the same as the one for ReplayBuffer, with an
added priority.
:returns:</p>
<blockquote>
<div><dl class="simple">
<dt>list of ReplayElements defining the type of the argument signature needed</dt><dd><p>by the add function.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_priority">
<code class="sig-name descname">get_priority</code><span class="sig-paren">(</span><em class="sig-param">indices</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches the priorities correspond to a batch of memory indices.
For any memory location not yet used, the corresponding priority is 0.
:param indices: np.array with dtype int32, of indices in range</p>
<blockquote>
<div><p>[0, replay_capacity).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>float, the corresponding priorities.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>priorities</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_transition_elements">
<code class="sig-name descname">get_transition_elements</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.get_transition_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ‘type signature’ for sample_transition_batch.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A namedtuple describing the method’s return type signature.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>signature</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.sample_index_batch">
<code class="sig-name descname">sample_index_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size: int</em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.sample_index_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of valid indices sampled as in Schaul et al. (2015).
:param batch_size: int, number of indices returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1D tensor of ints, a batch of valid indices sampled uniformly.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If the batch was not constructed after maximum number of tries.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.sample_transition_batch">
<code class="sig-name descname">sample_transition_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.sample_transition_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of transitions with extra storage and the priorities.
The extra storage are defined through the extra_storage_types constructor
argument.
When the transition is terminal next_state_batch has undefined contents.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>indices</strong> – None or 1D tensor of ints, the indices of every transition in the
batch. If None, sample the indices uniformly.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>tuple of np.arrays with the shape and type as in</dt><dd><p>get_transition_elements().</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>transition_batch</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.set_priority">
<code class="sig-name descname">set_priority</code><span class="sig-paren">(</span><em class="sig-param">indices</em>, <em class="sig-param">priorities</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.prioritized_replay_buffer.PrioritizedReplayBuffer.set_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the priority of the given elements according to Schaul et al.
:param indices: np.array with dtype int32, of indices in range</p>
<blockquote>
<div><p>[0, replay_capacity).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>priorities</strong> – float, the corresponding priorities.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-reagent.replay_memory.sum_tree">
<span id="reagent-replay-memory-sum-tree-module"></span><h2>reagent.replay_memory.sum_tree module<a class="headerlink" href="#module-reagent.replay_memory.sum_tree" title="Permalink to this headline">¶</a></h2>
<p>A sum tree data structure.
Used for prioritized experience replay. See prioritized_replay_buffer.py
and Schaul et al. (2015).</p>
<dl class="class">
<dt id="reagent.replay_memory.sum_tree.SumTree">
<em class="property">class </em><code class="sig-prename descclassname">reagent.replay_memory.sum_tree.</code><code class="sig-name descname">SumTree</code><span class="sig-paren">(</span><em class="sig-param">capacity: int</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.sum_tree.SumTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A sum tree data structure for storing replay priorities.
A sum tree is a complete binary tree whose leaves contain values called
priorities. Internal nodes maintain the sum of the priorities of all leaf
nodes in their subtree.
For capacity = 4, the tree may look like this:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p>2.5</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>+-+-+            +-+-+
<a href="#id3"><span class="problematic" id="id4">|1.5|</span></a>            <a href="#id5"><span class="problematic" id="id6">|1.0|</span></a>
+-+-+            +-+-+</p>
<blockquote>
<div><div class="line-block">
<div class="line"><a href="#id1"><span class="problematic" id="id2">|</span></a></div>
</div>
</div></blockquote>
</div></blockquote>
<p>+—-+—-+      +—-+—-+
|         |      |         |</p>
</div></blockquote>
<p>+-+-+     +-+-+  +-+-+     +-+-+
<a href="#id7"><span class="problematic" id="id8">|0.5|</span></a>     <a href="#id9"><span class="problematic" id="id10">|1.0|</span></a>  <a href="#id11"><span class="problematic" id="id12">|0.5|</span></a>     <a href="#id13"><span class="problematic" id="id14">|0.5|</span></a>
+—+     +—+  +—+     +—+
This is stored in a list of numpy arrays:
self.nodes = [ [2.5], [1.5, 1], [0.5, 1, 0.5, 0.5] ]
For conciseness, we allocate arrays as powers of two, and pad the excess
elements with zero values.
This is similar to the usual array-based representation of a complete binary
tree, but is a little more user-friendly.</p>
<dl class="method">
<dt id="reagent.replay_memory.sum_tree.SumTree.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">node_index: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#reagent.replay_memory.sum_tree.SumTree.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the leaf node corresponding to the index.
:param node_index: The index of the leaf node.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The value of the leaf node.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.sum_tree.SumTree.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">query_value: Optional[float] = None</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#reagent.replay_memory.sum_tree.SumTree.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples an element from the sum tree.
Each element has probability p_i / sum_j p_j of being picked, where p_i is
the (positive) value associated with node i (possibly unnormalized).
:param query_value: float in [0, 1], used as the random value to select a
:param sample. If None, will select one randomly in [0, 1).:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>int, a random element from the sum tree.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If the sum tree is empty (i.e. its node values sum to 0), or if
    the supplied query_value is larger than the total sum.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.sum_tree.SumTree.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">node_index: int</em>, <em class="sig-param">value: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#reagent.replay_memory.sum_tree.SumTree.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of a leaf node and updates internal nodes accordingly.
This operation takes O(log(capacity)).
:param node_index: int, the index of the leaf node to be updated.
:param value: float, the value which we assign to the node. This value must be</p>
<blockquote>
<div><p>nonnegative. Setting value = 0 will cause the element to never be
sampled.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the given value is negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.sum_tree.SumTree.stratified_sample">
<code class="sig-name descname">stratified_sample</code><span class="sig-paren">(</span><em class="sig-param">batch_size: int</em><span class="sig-paren">)</span> &#x2192; List[int]<a class="headerlink" href="#reagent.replay_memory.sum_tree.SumTree.stratified_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs stratified sampling using the sum tree.
Let R be the value at the root (total value of sum tree). This method will
divide [0, R) into batch_size segments, pick a random number from each of
those segments, and use that random number to sample from the sum_tree. This
is as specified in Schaul et al. (2015).
:param batch_size: int, the number of strata to use.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of batch_size elements sampled from the sum tree.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If the sum tree is empty (i.e. its node values sum to 0).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-reagent.replay_memory.utils">
<span id="reagent-replay-memory-utils-module"></span><h2>reagent.replay_memory.utils module<a class="headerlink" href="#module-reagent.replay_memory.utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="reagent.replay_memory.utils.replay_buffer_to_pre_timeline_df">
<code class="sig-prename descclassname">reagent.replay_memory.utils.</code><code class="sig-name descname">replay_buffer_to_pre_timeline_df</code><span class="sig-paren">(</span><em class="sig-param">is_discrete_action: bool</em>, <em class="sig-param">replay_buffer: reagent.replay_memory.circular_replay_buffer.ReplayBuffer</em><span class="sig-paren">)</span> &#x2192; pandas.DataFrame<a class="headerlink" href="#reagent.replay_memory.utils.replay_buffer_to_pre_timeline_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Format needed for uploading dataset to Hive, and then run timeline.</p>
</dd></dl>

</div>
<div class="section" id="module-reagent.replay_memory">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-reagent.replay_memory" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="reagent.replay_memory.ReplayBuffer">
<em class="property">class </em><code class="sig-prename descclassname">reagent.replay_memory.</code><code class="sig-name descname">ReplayBuffer</code><span class="sig-paren">(</span><em class="sig-param">observation_shape: Tuple[int, ...], stack_size: int, replay_capacity: int, batch_size: int, return_everything_as_stack: bool = False, return_as_timeline_format: bool = False, update_horizon: int = 1, gamma: float = 0.99, max_sample_attempts: int = 1000, extra_storage_types: Optional[List[reagent.replay_memory.circular_replay_buffer.shape_type]] = None, observation_dtype=numpy.uint8, action_shape: Tuple[int, ...] = (), action_dtype=numpy.int32, reward_shape: Tuple[int, ...] = (), reward_dtype=numpy.float32</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple Replay Buffer.
Stores transitions, state, action, reward, next_state, terminal (and any
extra contents specified) in a circular buffer and provides a uniform
transition sampling function.
When the states consist of stacks of observations storing the states is
inefficient. This class writes observations and constructs the stacked states
at sample time.
.. attribute:: add_count</p>
<blockquote>
<div><p>int, counter of how many transitions have been added (including
the blank ones at the beginning of an episode).</p>
</div></blockquote>
<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">observation</em>, <em class="sig-param">action</em>, <em class="sig-param">reward</em>, <em class="sig-param">terminal</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a transition to the replay memory.
This function checks the types and handles the padding at the beginning of
an episode. Then it calls the _add function.
Since the next_observation in the transition will be the observation added
next there is no need to pass it.
If the replay memory is at capacity the oldest transition will be discarded.
:param observation: np.array with shape observation_shape.
:param action: int, the action in the transition.
:param reward: float, the reward received in the transition.
:param terminal: np.dtype, acts as a boolean indicating whether the transition</p>
<blockquote>
<div><p>was terminal (1) or not (0).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*args</strong> – extra contents with shapes and dtypes according to
extra_storage_types.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.create_from_env">
<em class="property">classmethod </em><code class="sig-name descname">create_from_env</code><span class="sig-paren">(</span><em class="sig-param">env: gym.core.Env</em>, <em class="sig-param">*</em>, <em class="sig-param">replay_memory_size: int</em>, <em class="sig-param">batch_size: int</em>, <em class="sig-param">stack_size: int = 1</em>, <em class="sig-param">store_log_prob: bool = True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.create_from_env" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.cursor">
<code class="sig-name descname">cursor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Index to the location where the next transition will be written.</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.get_add_args_signature">
<code class="sig-name descname">get_add_args_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[reagent.replay_memory.circular_replay_buffer.shape_type]<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.get_add_args_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>The signature of the add function.
Note - Derived classes may return a different signature.
:returns:</p>
<blockquote>
<div><dl class="simple">
<dt>list of ReplayElements defining the type of the argument signature needed</dt><dd><p>by the add function.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.get_storage_signature">
<code class="sig-name descname">get_storage_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[reagent.replay_memory.circular_replay_buffer.shape_type]<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.get_storage_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a default list of elements to be stored in this replay memory.
Note - Derived classes may return a different signature.
:returns: list of ReplayElements defining the type of the contents stored.</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.get_transition_elements">
<code class="sig-name descname">get_transition_elements</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.get_transition_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ‘type signature’ for sample_transition_batch.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A namedtuple describing the method’s return type signature.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>signature</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.is_empty">
<code class="sig-name descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Replay Buffer empty?</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.is_full">
<code class="sig-name descname">is_full</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Replay Buffer full?</p>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.is_valid_transition">
<code class="sig-name descname">is_valid_transition</code><span class="sig-paren">(</span><em class="sig-param">index</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.is_valid_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">checkpoint_dir</em>, <em class="sig-param">suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores the object from bundle_dictionary and numpy checkpoints.
:param checkpoint_dir: str, the directory where to read the numpy checkpointed</p>
<blockquote>
<div><p>files from.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>suffix</strong> – str, the suffix to use in numpy checkpoint files.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotFoundError</strong> – If not all expected files are found in directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.sample_all_valid_transitions">
<code class="sig-name descname">sample_all_valid_transitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.sample_all_valid_transitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.sample_index_batch">
<code class="sig-name descname">sample_index_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size: int</em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.sample_index_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of valid indices sampled uniformly.
:param batch_size: int, number of indices returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1D tensor of ints, a batch of valid indices sampled uniformly.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If there are no valid indices to sample.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.sample_transition_batch">
<code class="sig-name descname">sample_transition_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.sample_transition_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of transitions (including any extra contents).
If get_transition_elements has been overridden and defines elements not
stored in self._store, an empty array will be returned and it will be
left to the child class to fill it. For example, for the child class
PrioritizedReplayBuffer, the contents of the
sampling_probabilities are stored separately in a sum tree.
When the transition is terminal next_state_batch has undefined contents.
NOTE: This transition contains the indices of the sampled elements. These
are only valid during the call to sample_transition_batch, i.e. they may
be used by subclasses of this replay buffer but may point to different data
as soon as sampling is done.
NOTE: Tensors are reshaped. I.e., state is 2-D unless stack_size &gt; 1.
Scalar values are returned as (batch_size, 1) instead of (batch_size,).
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>indices</strong> – None or Tensor, the indices of every transition in the
batch. If None, sample the indices uniformly.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>tuple of Tensors with the shape and type as in</dt><dd><p>get_transition_elements().</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>transition_batch</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an element to be sampled is missing from the replay buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">checkpoint_dir</em>, <em class="sig-param">iteration_number</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the ReplayBuffer attributes into a file.
This method will save all the replay buffer’s state in a single file.
:param checkpoint_dir: str, the directory where numpy checkpoint files should be</p>
<blockquote>
<div><p>saved.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iteration_number</strong> – int, iteration_number to use as a suffix in naming
numpy checkpoint files.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.set_index_valid_status">
<code class="sig-name descname">set_index_valid_status</code><span class="sig-paren">(</span><em class="sig-param">idx: int</em>, <em class="sig-param">is_valid: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.set_index_valid_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.ReplayBuffer.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#reagent.replay_memory.ReplayBuffer.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer">
<em class="property">class </em><code class="sig-prename descclassname">reagent.replay_memory.</code><code class="sig-name descname">PrioritizedReplayBuffer</code><span class="sig-paren">(</span><em class="sig-param">observation_shape</em>, <em class="sig-param">stack_size</em>, <em class="sig-param">replay_capacity</em>, <em class="sig-param">batch_size</em>, <em class="sig-param">update_horizon=1</em>, <em class="sig-param">gamma=0.99</em>, <em class="sig-param">max_sample_attempts=1000</em>, <em class="sig-param">extra_storage_types=None</em>, <em class="sig-param">observation_dtype=numpy.uint8</em>, <em class="sig-param">action_shape=()</em>, <em class="sig-param">action_dtype=numpy.int32</em>, <em class="sig-param">reward_shape=()</em>, <em class="sig-param">reward_dtype=numpy.float32</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#reagent.replay_memory.circular_replay_buffer.ReplayBuffer" title="reagent.replay_memory.circular_replay_buffer.ReplayBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">reagent.replay_memory.circular_replay_buffer.ReplayBuffer</span></code></a></p>
<p>An out-of-graph Replay Buffer for Prioritized Experience Replay.
See circular_replay_buffer.py for details.</p>
<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.get_add_args_signature">
<code class="sig-name descname">get_add_args_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.get_add_args_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>The signature of the add function.
The signature is the same as the one for ReplayBuffer, with an
added priority.
:returns:</p>
<blockquote>
<div><dl class="simple">
<dt>list of ReplayElements defining the type of the argument signature needed</dt><dd><p>by the add function.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.get_priority">
<code class="sig-name descname">get_priority</code><span class="sig-paren">(</span><em class="sig-param">indices</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.get_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches the priorities correspond to a batch of memory indices.
For any memory location not yet used, the corresponding priority is 0.
:param indices: np.array with dtype int32, of indices in range</p>
<blockquote>
<div><p>[0, replay_capacity).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>float, the corresponding priorities.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>priorities</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.get_transition_elements">
<code class="sig-name descname">get_transition_elements</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.get_transition_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ‘type signature’ for sample_transition_batch.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A namedtuple describing the method’s return type signature.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>signature</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.sample_index_batch">
<code class="sig-name descname">sample_index_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size: int</em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.sample_index_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of valid indices sampled as in Schaul et al. (2015).
:param batch_size: int, number of indices returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>1D tensor of ints, a batch of valid indices sampled uniformly.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If the batch was not constructed after maximum number of tries.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.sample_transition_batch">
<code class="sig-name descname">sample_transition_batch</code><span class="sig-paren">(</span><em class="sig-param">batch_size=None</em>, <em class="sig-param">indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.sample_transition_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch of transitions with extra storage and the priorities.
The extra storage are defined through the extra_storage_types constructor
argument.
When the transition is terminal next_state_batch has undefined contents.
:param batch_size: int, number of transitions returned. If None, the default</p>
<blockquote>
<div><p>batch_size will be used.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>indices</strong> – None or 1D tensor of ints, the indices of every transition in the
batch. If None, sample the indices uniformly.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>tuple of np.arrays with the shape and type as in</dt><dd><p>get_transition_elements().</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>transition_batch</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="reagent.replay_memory.PrioritizedReplayBuffer.set_priority">
<code class="sig-name descname">set_priority</code><span class="sig-paren">(</span><em class="sig-param">indices</em>, <em class="sig-param">priorities</em><span class="sig-paren">)</span><a class="headerlink" href="#reagent.replay_memory.PrioritizedReplayBuffer.set_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the priority of the given elements according to Schaul et al.
:param indices: np.array with dtype int32, of indices in range</p>
<blockquote>
<div><p>[0, replay_capacity).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>priorities</strong> – float, the corresponding priorities.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="reagent.training.html" class="btn btn-neutral float-right" title="reagent.training package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="reagent.preprocessing.html" class="btn btn-neutral float-left" title="reagent.preprocessing package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Facebook Inc.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>